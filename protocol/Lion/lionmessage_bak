// enum class LionMessage {
//   READ_LOCK_REQUEST = static_cast<int>(ControlMessage::NFIELDS),
//   READ_LOCK_RESPONSE,
//   WRITE_LOCK_REQUEST,
//   WRITE_LOCK_RESPONSE,
//   ABORT_REQUEST,
//   WRITE_REQUEST,
//   WRITE_RESPONSE,
//   REPLICATION_REQUEST,
//   REPLICATION_RESPONSE,
//   RELEASE_READ_LOCK_REQUEST,
//   RELEASE_READ_LOCK_RESPONSE,
//   RELEASE_WRITE_LOCK_REQUEST,
//   RELEASE_WRITE_LOCK_RESPONSE,
//   NFIELDS
// };

// class LionMessageFactory {

// public:
//   static std::size_t new_read_lock_message(Message &message, ITable &table,
//                                            const void *key,
//                                            uint32_t key_offset) {

//     /*
//      * The structure of a read lock request: (primary key, key offset)
//      */

//     auto key_size = table.key_size();

//     auto message_size =
//         MessagePiece::get_header_size() + key_size + sizeof(key_offset);
//     auto message_piece_header = MessagePiece::construct_message_piece_header(
//         static_cast<uint32_t>(TwoPLMessage::READ_LOCK_REQUEST), message_size,
//         table.tableID(), table.partitionID());

//     Encoder encoder(message.data);
//     encoder << message_piece_header;
//     encoder.write_n_bytes(key, key_size);
//     encoder << key_offset;
//     message.flush();
//     return message_size;
//   }

//   static std::size_t new_write_lock_message(Message &message, ITable &table,
//                                             const void *key,
//                                             uint32_t key_offset) {

//     /*
//      * The structure of a write lock request: (primary key, key offset)
//      */

//     auto key_size = table.key_size();

//     auto message_size =
//         MessagePiece::get_header_size() + key_size + sizeof(key_offset);
//     auto message_piece_header = MessagePiece::construct_message_piece_header(
//         static_cast<uint32_t>(TwoPLMessage::WRITE_LOCK_REQUEST), message_size,
//         table.tableID(), table.partitionID());

//     Encoder encoder(message.data);
//     encoder << message_piece_header;
//     encoder.write_n_bytes(key, key_size);
//     encoder << key_offset;
//     message.flush();
//     return message_size;
//   }

//   static std::size_t new_abort_message(Message &message, ITable &table,
//                                        const void *key, bool write_lock) {
//     /*
//      * The structure of an abort request: (primary key, wrtie lock)
//      */

//     auto key_size = table.key_size();

//     auto message_size =
//         MessagePiece::get_header_size() + key_size + sizeof(bool);
//     auto message_piece_header = MessagePiece::construct_message_piece_header(
//         static_cast<uint32_t>(TwoPLMessage::ABORT_REQUEST), message_size,
//         table.tableID(), table.partitionID());

//     Encoder encoder(message.data);
//     encoder << message_piece_header;
//     encoder.write_n_bytes(key, key_size);
//     encoder << write_lock;
//     message.flush();
//     return message_size;
//   }

//   static std::size_t new_write_message(Message &message, ITable &table,
//                                        const void *key, const void *value) {

//     /*
//      * The structure of a write request: (primary key, field value)
//      */

//     auto key_size = table.key_size();
//     auto field_size = table.field_size();

//     auto message_size = MessagePiece::get_header_size() + key_size + field_size;
//     auto message_piece_header = MessagePiece::construct_message_piece_header(
//         static_cast<uint32_t>(TwoPLMessage::WRITE_REQUEST), message_size,
//         table.tableID(), table.partitionID());

//     Encoder encoder(message.data);
//     encoder << message_piece_header;
//     encoder.write_n_bytes(key, key_size);
//     table.serialize_value(encoder, value);
//     message.flush();
//     return message_size;
//   }

//   static std::size_t new_replication_message(Message &message, ITable &table,
//                                              const void *key, const void *value,
//                                              uint64_t commit_tid) {

//     /*
//      * The structure of a replication request: (primary key, field value,
//      * commit_tid)
//      */

//     auto key_size = table.key_size();
//     auto field_size = table.field_size();

//     auto message_size = MessagePiece::get_header_size() + key_size +
//                         field_size + sizeof(commit_tid);
//     auto message_piece_header = MessagePiece::construct_message_piece_header(
//         static_cast<uint32_t>(TwoPLMessage::REPLICATION_REQUEST), message_size,
//         table.tableID(), table.partitionID());

//     Encoder encoder(message.data);
//     encoder << message_piece_header;
//     encoder.write_n_bytes(key, key_size);
//     table.serialize_value(encoder, value);
//     encoder << commit_tid;
//     message.flush();
//     return message_size;
//   }

//   static std::size_t new_release_read_lock_message(Message &message,
//                                                    ITable &table,
//                                                    const void *key) {
//     /*
//      * The structure of a release read lock request: (primary key)
//      */

//     auto key_size = table.key_size();

//     auto message_size = MessagePiece::get_header_size() + key_size;
//     auto message_piece_header = MessagePiece::construct_message_piece_header(
//         static_cast<uint32_t>(TwoPLMessage::RELEASE_READ_LOCK_REQUEST),
//         message_size, table.tableID(), table.partitionID());

//     Encoder encoder(message.data);
//     encoder << message_piece_header;
//     encoder.write_n_bytes(key, key_size);
//     message.flush();
//     return message_size;
//   }

//   static std::size_t new_release_write_lock_message(Message &message,
//                                                     ITable &table,
//                                                     const void *key,
//                                                     uint64_t commit_tid) {

//     /*
//      * The structure of a release write lock request: (primary key, commit tid)
//      */

//     auto key_size = table.key_size();

//     auto message_size =
//         MessagePiece::get_header_size() + key_size + sizeof(commit_tid);
//     auto message_piece_header = MessagePiece::construct_message_piece_header(
//         static_cast<uint32_t>(TwoPLMessage::RELEASE_WRITE_LOCK_REQUEST),
//         message_size, table.tableID(), table.partitionID());

//     Encoder encoder(message.data);
//     encoder << message_piece_header;
//     encoder.write_n_bytes(key, key_size);
//     encoder << commit_tid;
//     message.flush();
//     return message_size;
//   }
// };

// template<class Database>class LionMessageHandler {
//   using Transaction = TwoPLTransaction;

// public:
//   static void read_lock_request_handler(MessagePiece inputPiece,
//                                         Message &responseMessage, Database &db,
//                                         Transaction *txn) {
//     DCHECK(inputPiece.get_message_type() ==
//            static_cast<uint32_t>(TwoPLMessage::READ_LOCK_REQUEST));
//     auto table_id = inputPiece.get_table_id();
//     auto partition_id = inputPiece.get_partition_id();
//     ITable &table = *db.find_table(table_id, partition_id);
    
//     DCHECK(table_id == table.tableID());
//     DCHECK(partition_id == table.partitionID());
//     auto key_size = table.key_size();
//     auto value_size = table.value_size();

//     /*
//      * The structure of a read lock request: (primary key, key offset)
//      * The structure of a read lock response: (success?, key offset, value?,
//      * tid?)
//      */

//     auto stringPiece = inputPiece.toStringPiece();
//     uint32_t key_offset;

//     DCHECK(inputPiece.get_message_length() ==
//            MessagePiece::get_header_size() + key_size + sizeof(key_offset));

//     const void *key = stringPiece.data();
//     auto row = table.search(key);
//     std::atomic<uint64_t> &tid = *std::get<0>(row);

//     stringPiece.remove_prefix(key_size);
//     star::Decoder dec(stringPiece);
//     dec >> key_offset;

//     DCHECK(dec.size() == 0);

//     bool success;
//     uint64_t latest_tid = TwoPLHelper::read_lock(tid, success);

//     // prepare response message header
//     auto message_size =
//         MessagePiece::get_header_size() + sizeof(bool) + sizeof(key_offset);

//     if (success) {
//       message_size += value_size + sizeof(uint64_t);
//     }

//     auto message_piece_header = MessagePiece::construct_message_piece_header(
//         static_cast<uint32_t>(TwoPLMessage::READ_LOCK_RESPONSE), message_size,
//         table_id, partition_id);

//     star::Encoder encoder(responseMessage.data);
//     encoder << message_piece_header;
//     encoder << success << key_offset;

//     if (success) {
//       // reserve size for read
//       responseMessage.data.append(value_size, 0);
//       void *dest =
//           &responseMessage.data[0] + responseMessage.data.size() - value_size;
//       // read to message buffer
//       TwoPLHelper::read(row, dest, value_size);
//       encoder << latest_tid;
//     }

//     responseMessage.flush();
//   }

//   static void read_lock_response_handler(MessagePiece inputPiece,
//                                          Message &responseMessage,
//                                          Database &db, Transaction *txn) {
//     DCHECK(inputPiece.get_message_type() ==
//            static_cast<uint32_t>(TwoPLMessage::READ_LOCK_RESPONSE));
//     auto table_id = inputPiece.get_table_id();
//     auto partition_id = inputPiece.get_partition_id();
//     ITable &table = *db.find_table(table_id, partition_id);
    
//     DCHECK(table_id == table.tableID());
//     DCHECK(partition_id == table.partitionID());
//     auto key_size = table.key_size();
//     auto value_size = table.value_size();

//     /*
//      * The structure of a read lock response: (success?, key offset, value?,
//      * tid?)
//      */

//     bool success;
//     uint32_t key_offset;

//     StringPiece stringPiece = inputPiece.toStringPiece();
//     Decoder dec(stringPiece);
//     dec >> success >> key_offset;

//     if (success) {
//       DCHECK(inputPiece.get_message_length() ==
//              MessagePiece::get_header_size() + sizeof(success) +
//                  sizeof(key_offset) + value_size + sizeof(uint64_t));

//       TwoPLRWKey &readKey = txn->readSet[key_offset];
//       dec.read_n_bytes(readKey.get_value(), value_size);
//       uint64_t tid;
//       dec >> tid;
//       readKey.set_read_lock_bit();
//       readKey.set_tid(tid);
//     } else {
//       DCHECK(inputPiece.get_message_length() ==
//              MessagePiece::get_header_size() + sizeof(success) +
//                  sizeof(key_offset));

//       txn->abort_lock = true;
//     }

//     txn->pendingResponses--;
//     txn->network_size += inputPiece.get_message_length();
//   }

//   static void write_lock_request_handler(MessagePiece inputPiece,
//                                          Message &responseMessage,
//                                          Database &db, Transaction *txn) {

//     DCHECK(inputPiece.get_message_type() ==
//            static_cast<uint32_t>(TwoPLMessage::WRITE_LOCK_REQUEST));
//     auto table_id = inputPiece.get_table_id();
//     auto partition_id = inputPiece.get_partition_id();
//     ITable &table = *db.find_table(table_id, partition_id);

//     DCHECK(table_id == table.tableID());
//     DCHECK(partition_id == table.partitionID());
//     auto key_size = table.key_size();
//     auto value_size = table.value_size();

//     /*
//      * The structure of a write lock request: (primary key, key offset)
//      * The structure of a write lock response: (success?, key offset, value?,
//      * tid?)
//      */

//     auto stringPiece = inputPiece.toStringPiece();
//     uint32_t key_offset;

//     DCHECK(inputPiece.get_message_length() ==
//            MessagePiece::get_header_size() + key_size + sizeof(key_offset));

//     const void *key = stringPiece.data();
//     auto row = table.search(key);
//     std::atomic<uint64_t> &tid = *std::get<0>(row);

//     stringPiece.remove_prefix(key_size);
//     star::Decoder dec(stringPiece);
//     dec >> key_offset;

//     DCHECK(dec.size() == 0);

//     bool success;
//     uint64_t latest_tid = TwoPLHelper::write_lock(tid, success);

//     // prepare response message header
//     auto message_size =
//         MessagePiece::get_header_size() + sizeof(bool) + sizeof(key_offset);

//     if (success) {
//       message_size += value_size + sizeof(uint64_t);
//     }

//     auto message_piece_header = MessagePiece::construct_message_piece_header(
//         static_cast<uint32_t>(TwoPLMessage::WRITE_LOCK_RESPONSE), message_size,
//         table_id, partition_id);

//     star::Encoder encoder(responseMessage.data);
//     encoder << message_piece_header;
//     encoder << success << key_offset;

//     if (success) {
//       // reserve size for read
//       responseMessage.data.append(value_size, 0);
//       void *dest =
//           &responseMessage.data[0] + responseMessage.data.size() - value_size;
//       // read to message buffer
//       TwoPLHelper::read(row, dest, value_size);
//       encoder << latest_tid;
//     }

//     responseMessage.flush();
//   }

//   static void write_lock_response_handler(MessagePiece inputPiece,
//                                           Message &responseMessage,
//                                           Database &db, Transaction *txn) {
//     DCHECK(inputPiece.get_message_type() ==
//            static_cast<uint32_t>(TwoPLMessage::WRITE_LOCK_RESPONSE));
//     auto table_id = inputPiece.get_table_id();
//     auto partition_id = inputPiece.get_partition_id();
//     ITable &table = *db.find_table(table_id, partition_id);

//     DCHECK(table_id == table.tableID());
//     DCHECK(partition_id == table.partitionID());
//     auto key_size = table.key_size();
//     auto value_size = table.value_size();

//     /*
//      * The structure of a read lock response: (success?, key offset, value?,
//      * tid?)
//      */

//     bool success;
//     uint32_t key_offset;

//     StringPiece stringPiece = inputPiece.toStringPiece();
//     Decoder dec(stringPiece);
//     dec >> success >> key_offset;

//     if (success) {
//       DCHECK(inputPiece.get_message_length() ==
//              MessagePiece::get_header_size() + sizeof(success) +
//                  sizeof(key_offset) + value_size + sizeof(uint64_t));

//       TwoPLRWKey &readKey = txn->readSet[key_offset];
//       dec.read_n_bytes(readKey.get_value(), value_size);
//       uint64_t tid;
//       dec >> tid;
//       readKey.set_write_lock_bit();
//       readKey.set_tid(tid);
//     } else {
//       DCHECK(inputPiece.get_message_length() ==
//              MessagePiece::get_header_size() + sizeof(success) +
//                  sizeof(key_offset));

//       txn->abort_lock = true;
//     }

//     txn->pendingResponses--;
//     txn->network_size += inputPiece.get_message_length();
//   }

//   static void abort_request_handler(MessagePiece inputPiece,
//                                     Message &responseMessage, Database &db,
//                                     Transaction *txn) {

//     DCHECK(inputPiece.get_message_type() ==
//            static_cast<uint32_t>(TwoPLMessage::ABORT_REQUEST));
//     auto table_id = inputPiece.get_table_id();
//     auto partition_id = inputPiece.get_partition_id();
//     ITable &table = *db.find_table(table_id, partition_id);

//     DCHECK(table_id == table.tableID());
//     DCHECK(partition_id == table.partitionID());
//     auto key_size = table.key_size();

//     /*
//      * The structure of an abort request: (primary key, write_lock)
//      * The structure of an abort response: null
//      */

//     DCHECK(inputPiece.get_message_length() ==
//            MessagePiece::get_header_size() + key_size + sizeof(bool));

//     auto stringPiece = inputPiece.toStringPiece();

//     const void *key = stringPiece.data();
//     stringPiece.remove_prefix(key_size);

//     bool write_lock;
//     Decoder dec(stringPiece);
//     dec >> write_lock;

//     std::atomic<uint64_t> &tid = table.search_metadata(key);

//     if (write_lock) {
//       TwoPLHelper::write_lock_release(tid);
//     } else {
//       TwoPLHelper::read_lock_release(tid);
//     }
//   }

//   static void write_request_handler(MessagePiece inputPiece,
//                                     Message &responseMessage, Database &db,
//                                     Transaction *txn) {

//     DCHECK(inputPiece.get_message_type() ==
//            static_cast<uint32_t>(TwoPLMessage::WRITE_REQUEST));
//     auto table_id = inputPiece.get_table_id();
//     auto partition_id = inputPiece.get_partition_id();
//     ITable &table = *db.find_table(table_id, partition_id);
    
//     DCHECK(table_id == table.tableID());
//     DCHECK(partition_id == table.partitionID());
//     auto key_size = table.key_size();
//     auto field_size = table.field_size();

//     /*
//      * The structure of a write request: (primary key, field value)
//      * The structure of a write response: ()
//      */

//     DCHECK(inputPiece.get_message_length() ==
//            MessagePiece::get_header_size() + key_size + field_size);

//     auto stringPiece = inputPiece.toStringPiece();

//     const void *key = stringPiece.data();
//     stringPiece.remove_prefix(key_size);

//     table.deserialize_value(key, stringPiece);

//     // prepare response message header
//     auto message_size = MessagePiece::get_header_size();
//     auto message_piece_header = MessagePiece::construct_message_piece_header(
//         static_cast<uint32_t>(TwoPLMessage::WRITE_RESPONSE), message_size,
//         table_id, partition_id);

//     star::Encoder encoder(responseMessage.data);
//     encoder << message_piece_header;
//     responseMessage.flush();
//   }

//   static void write_response_handler(MessagePiece inputPiece,
//                                      Message &responseMessage, Database &db,
//                                      Transaction *txn) {

//     DCHECK(inputPiece.get_message_type() ==
//            static_cast<uint32_t>(TwoPLMessage::WRITE_RESPONSE));
//     auto table_id = inputPiece.get_table_id();
//     auto partition_id = inputPiece.get_partition_id();
//     ITable &table = *db.find_table(table_id, partition_id);

//     DCHECK(table_id == table.tableID());
//     DCHECK(partition_id == table.partitionID());
//     auto key_size = table.key_size();

//     /*
//      * The structure of a write response: ()
//      */

//     txn->pendingResponses--;
//     txn->network_size += inputPiece.get_message_length();
//   }

//   static void replication_request_handler(MessagePiece inputPiece,
//                                           Message &responseMessage,
//                                           Database &db, Transaction *txn) {
//     DCHECK(inputPiece.get_message_type() ==
//            static_cast<uint32_t>(TwoPLMessage::REPLICATION_REQUEST));
//     auto table_id = inputPiece.get_table_id();
//     auto partition_id = inputPiece.get_partition_id();
//     ITable &table = *db.find_table(table_id, partition_id);

//     DCHECK(table_id == table.tableID());
//     DCHECK(partition_id == table.partitionID());
//     auto key_size = table.key_size();
//     auto field_size = table.field_size();

//     /*
//      * The structure of a replication request: (primary key, field value, commit
//      * tid) The structure of a replication response: ()
//      */

//     auto stringPiece = inputPiece.toStringPiece();

//     const void *key = stringPiece.data();
//     stringPiece.remove_prefix(key_size);
//     auto valueStringPiece = stringPiece;
//     stringPiece.remove_prefix(field_size);

//     uint64_t commit_tid;
//     Decoder dec(stringPiece);
//     dec >> commit_tid;

//     DCHECK(dec.size() == 0);

//     std::atomic<uint64_t> &tid = table.search_metadata(key);

//     uint64_t last_tid = TwoPLHelper::write_lock(tid);
//     DCHECK(last_tid < commit_tid);
//     table.deserialize_value(key, valueStringPiece);
//     TwoPLHelper::write_lock_release(tid, commit_tid);

//     // prepare response message header
//     auto message_size = MessagePiece::get_header_size();
//     auto message_piece_header = MessagePiece::construct_message_piece_header(
//         static_cast<uint32_t>(TwoPLMessage::REPLICATION_RESPONSE), message_size,
//         table_id, partition_id);

//     star::Encoder encoder(responseMessage.data);
//     encoder << message_piece_header;
//     responseMessage.flush();
//   }

//   static void replication_response_handler(MessagePiece inputPiece,
//                                            Message &responseMessage,
//                                            Database &db, Transaction *txn) {

//     DCHECK(inputPiece.get_message_type() ==
//            static_cast<uint32_t>(TwoPLMessage::REPLICATION_RESPONSE));
//     auto table_id = inputPiece.get_table_id();
//     auto partition_id = inputPiece.get_partition_id();
//     ITable &table = *db.find_table(table_id, partition_id);

//     DCHECK(table_id == table.tableID());
//     DCHECK(partition_id == table.partitionID());
//     auto key_size = table.key_size();

//     /*
//      * The structure of a replication response: ()
//      */

//     txn->pendingResponses--;
//     txn->network_size += inputPiece.get_message_length();
//   }

//   static void release_read_lock_request_handler(MessagePiece inputPiece,
//                                                 Message &responseMessage,
//                                                 Database &db,
//                                                 Transaction *txn) {

//     DCHECK(inputPiece.get_message_type() ==
//            static_cast<uint32_t>(TwoPLMessage::RELEASE_READ_LOCK_REQUEST));
//     auto table_id = inputPiece.get_table_id();
//     auto partition_id = inputPiece.get_partition_id();
    
//     ITable &table = *db.find_table(table_id, partition_id);

//     DCHECK(table_id == table.tableID());
//     DCHECK(partition_id == table.partitionID());
//     auto key_size = table.key_size();

//     /*
//      * The structure of a release read lock request: (primary key)
//      * The structure of a release read lock response: ()
//      */

//     DCHECK(inputPiece.get_message_length() ==
//            MessagePiece::get_header_size() + key_size);

//     auto stringPiece = inputPiece.toStringPiece();

//     const void *key = stringPiece.data();
//     stringPiece.remove_prefix(key_size);

//     std::atomic<uint64_t> &tid = table.search_metadata(key);

//     TwoPLHelper::read_lock_release(tid);

//     // prepare response message header
//     auto message_size = MessagePiece::get_header_size();
//     auto message_piece_header = MessagePiece::construct_message_piece_header(
//         static_cast<uint32_t>(TwoPLMessage::RELEASE_READ_LOCK_RESPONSE),
//         message_size, table_id, partition_id);

//     star::Encoder encoder(responseMessage.data);
//     encoder << message_piece_header;
//     responseMessage.flush();
//   }

//   static void release_read_lock_response_handler(MessagePiece inputPiece,
//                                                  Message &responseMessage,
//                                                  Database &db,
//                                                  Transaction *txn) {

//     DCHECK(inputPiece.get_message_type() ==
//            static_cast<uint32_t>(TwoPLMessage::RELEASE_READ_LOCK_RESPONSE));
//     auto table_id = inputPiece.get_table_id();
//     auto partition_id = inputPiece.get_partition_id();
    
//     ITable &table = *db.find_table(table_id, partition_id);

//     DCHECK(table_id == table.tableID());
//     DCHECK(partition_id == table.partitionID());
//     auto key_size = table.key_size();

//     /*
//      * The structure of a release read lock response: ()
//      */

//     txn->pendingResponses--;
//     txn->network_size += inputPiece.get_message_length();
//   }

//   static void release_write_lock_request_handler(MessagePiece inputPiece,
//                                                  Message &responseMessage,
//                                                  Database &db,
//                                                  Transaction *txn) {

//     DCHECK(inputPiece.get_message_type() ==
//            static_cast<uint32_t>(TwoPLMessage::RELEASE_WRITE_LOCK_REQUEST));
//     auto table_id = inputPiece.get_table_id();
//     auto partition_id = inputPiece.get_partition_id();
//     ITable &table = *db.find_table(table_id, partition_id);

//     DCHECK(table_id == table.tableID());
//     DCHECK(partition_id == table.partitionID());
//     auto key_size = table.key_size();
//     /*
//      * The structure of a release write lock request: (primary key, commit tid)
//      * The structure of a release write lock response: ()
//      */

//     DCHECK(inputPiece.get_message_length() ==
//            MessagePiece::get_header_size() + key_size + sizeof(uint64_t));

//     auto stringPiece = inputPiece.toStringPiece();

//     const void *key = stringPiece.data();
//     stringPiece.remove_prefix(key_size);

//     uint64_t commit_tid;
//     Decoder dec(stringPiece);
//     dec >> commit_tid;

//     std::atomic<uint64_t> &tid = table.search_metadata(key);
//     TwoPLHelper::write_lock_release(tid, commit_tid);

//     // prepare response message header
//     auto message_size = MessagePiece::get_header_size();
//     auto message_piece_header = MessagePiece::construct_message_piece_header(
//         static_cast<uint32_t>(TwoPLMessage::RELEASE_WRITE_LOCK_RESPONSE),
//         message_size, table_id, partition_id);

//     star::Encoder encoder(responseMessage.data);
//     encoder << message_piece_header;
//     responseMessage.flush();
//   }

//   static void release_write_lock_response_handler(MessagePiece inputPiece,
//                                                   Message &responseMessage,
//                                                   Database &db,
//                                                   Transaction *txn) {
//     DCHECK(inputPiece.get_message_type() ==
//            static_cast<uint32_t>(TwoPLMessage::RELEASE_WRITE_LOCK_RESPONSE));
//     auto table_id = inputPiece.get_table_id();
//     auto partition_id = inputPiece.get_partition_id();
//     ITable &table = *db.find_table(table_id, partition_id);

//     DCHECK(table_id == table.tableID());
//     DCHECK(partition_id == table.partitionID());
//     auto key_size = table.key_size();

//     /*
//      * The structure of a release write lock response: ()
//      */

//     txn->pendingResponses--;
//     txn->network_size += inputPiece.get_message_length();
//   }

// public:
//   static std::vector<
//       std::function<void(MessagePiece, Message &, Database &, Transaction *)>>
//   get_message_handlers() {
//     std::vector<
//         std::function<void(MessagePiece, Message &, Database &, Transaction *)>>
//         v;
//     v.resize(static_cast<int>(ControlMessage::NFIELDS));
//     v.push_back(read_lock_request_handler);
//     v.push_back(read_lock_response_handler);
//     v.push_back(write_lock_request_handler);
//     v.push_back(write_lock_response_handler);
//     v.push_back(abort_request_handler);
//     v.push_back(write_request_handler);
//     v.push_back(write_response_handler);
//     v.push_back(replication_request_handler);
//     v.push_back(replication_response_handler);
//     v.push_back(release_read_lock_request_handler);
//     v.push_back(release_read_lock_response_handler);
//     v.push_back(release_write_lock_request_handler);
//     v.push_back(release_write_lock_response_handler);
//     return v;
//   }
// };




  // uint64_t generate_tid(TransactionType &txn) {

  //   auto &readSet = txn.readSet;
  //   auto &writeSet = txn.writeSet;

  //   uint64_t next_tid = 0;

  //   // larger than the TID of any record read or written by the transaction

  //   for (std::size_t i = 0; i < readSet.size(); i++) {
  //     next_tid = std::max(next_tid, readSet[i].get_tid());
  //   }

  //   // larger than the worker's most recent chosen TID

  //   next_tid = std::max(next_tid, max_tid);

  //   // increment

  //   next_tid++;

  //   // update worker's most recent chosen TID

  //   max_tid = next_tid;

  //   return next_tid;
  // }

  // void abort(TransactionType &txn,
  //            std::vector<std::unique_ptr<Message>> &messages) {

  //   // assume all writes are updates
  //   auto &readSet = txn.readSet;

  //   for (auto i = 0u; i < readSet.size(); i++) {
  //     auto &readKey = readSet[i];
  //     auto tableId = readKey.get_table_id();
  //     auto partitionId = readKey.get_partition_id();
  //     auto table = db.find_table(tableId, partitionId);
  //     auto key = readKey.get_key();
  //     if (readKey.get_read_lock_bit()) {
  //       if (partitioner.has_master_partition(tableId , partitionId, key)) {
          
  //         auto value = readKey.get_value();
  //         std::atomic<uint64_t> &tid = table->search_metadata(key);
  //         TwoPLHelper::read_lock_release(tid);
  //       } else {
  //         auto coordinatorID = partitioner.master_coordinator(tableId, partitionId, key);
  //         txn.network_size += MessageFactoryType::new_abort_message(
  //             *messages[coordinatorID], *table, readKey.get_key(), false);
  //       }
  //     }
      
  //     if (readKey.get_write_lock_bit()) {
  //       if (partitioner.has_master_partition(tableId , partitionId, key)) {
          
  //         auto value = readKey.get_value();
  //         std::atomic<uint64_t> &tid = table->search_metadata(key);
  //         TwoPLHelper::write_lock_release(tid);
  //       } else {
  //         auto coordinatorID = partitioner.master_coordinator(tableId, partitionId, key);
  //         txn.network_size += MessageFactoryType::new_abort_message(
  //             *messages[coordinatorID], *table, readKey.get_key(), true);
  //       }
  //     }
  //   }

  //   sync_messages(txn, false);
  // }

  // bool commit(TransactionType &txn,
  //             std::vector<std::unique_ptr<Message>> &messages) {

  //   if (txn.abort_lock) {
  //     abort(txn, messages);
  //     return false;
  //   }

  //   // all locks are acquired

  //   // generate tid
  //   uint64_t commit_tid = generate_tid(txn);

  //   // write and replicate
  //   write_and_replicate(txn, commit_tid, messages);

  //   // release locks
  //   release_lock(txn, commit_tid, messages);

  //   return true;
  // }

  // void write_and_replicate(TransactionType &txn, uint64_t commit_tid,
  //                          std::vector<std::unique_ptr<Message>> &messages) {

  //   auto &readSet = txn.readSet;
  //   auto &writeSet = txn.writeSet;

  //   for (auto i = 0u; i < writeSet.size(); i++) {
  //     auto &writeKey = writeSet[i];
  //     auto tableId = writeKey.get_table_id();
  //     auto partitionId = writeKey.get_partition_id();
  //     auto table = db.find_table(tableId, partitionId);
  //     auto key = writeKey.get_key();
  //     // write
  //     if (partitioner.has_master_partition(tableId , partitionId, key)) {
        
  //       auto value = writeKey.get_value();
  //       table->update(key, value);
  //     } else {
  //       txn.pendingResponses++;
  //       auto coordinatorID = partitioner.master_coordinator(tableId, partitionId, key);
  //       txn.network_size += MessageFactoryType::new_write_message(
  //           *messages[coordinatorID], *table, writeKey.get_key(),
  //           writeKey.get_value());
  //     }

  //     // value replicate

  //     std::size_t replicate_count = 0;

  //     for (auto k = 0u; k < partitioner.total_coordinators(); k++) {

  //       // k does not have this partition
  //       if (!partitioner.is_partition_replicated_on(tableId, partitionId, key, k)) {
  //         continue;
  //       }

  //       // already write
  //       if (k == partitioner.master_coordinator(tableId, partitionId, key)) {
  //         continue;
  //       }

  //       replicate_count++;

  //       // local replicate
  //       if (k == txn.coordinator_id) {
  //         auto key = writeKey.get_key();
  //         auto value = writeKey.get_value();
  //         table->update(key, value);
  //       } else {

  //         txn.pendingResponses++;
  //         auto coordinatorID = k;
  //         txn.network_size += MessageFactoryType::new_replication_message(
  //             *messages[coordinatorID], *table, writeKey.get_key(),
  //             writeKey.get_value(), commit_tid);
  //       }
  //     }

  //     // DCHECK(replicate_count == partitioner.replica_num() - 1);
  //   }
  //   sync_messages(txn);
  // }

  // void release_lock(TransactionType &txn, uint64_t commit_tid,
  //                   std::vector<std::unique_ptr<Message>> &messages) {

  //   // release read locks
  //   auto &readSet = txn.readSet;

  //   for (auto i = 0u; i < readSet.size(); i++) {
  //     auto &readKey = readSet[i];
  //     auto tableId = readKey.get_table_id();
  //     auto partitionId = readKey.get_partition_id();
  //     auto table = db.find_table(tableId, partitionId);
  //     if (readKey.get_read_lock_bit()) {
  //       auto key = readKey.get_key();
  //       if (partitioner.has_master_partition(tableId , partitionId, key)) {
  //         auto value = readKey.get_value();
  //         std::atomic<uint64_t> &tid = table->search_metadata(key);
  //         TwoPLHelper::read_lock_release(tid);
  //       } else {
  //         txn.pendingResponses++;
  //         auto coordinatorID = partitioner.master_coordinator(tableId, partitionId, key);
  //         txn.network_size += MessageFactoryType::new_release_read_lock_message(
  //             *messages[coordinatorID], *table, readKey.get_key());
  //       }
  //     }
  //   }

  //   // release write lock
  //   auto &writeSet = txn.writeSet;
  //   for (auto i = 0u; i < writeSet.size(); i++) {
  //     auto &writeKey = writeSet[i];
  //     auto tableId = writeKey.get_table_id();
  //     auto partitionId = writeKey.get_partition_id();
  //     auto table = db.find_table(tableId, partitionId);
  //     // write
  //     auto key = writeKey.get_key();
  //     if (partitioner.has_master_partition(tableId , partitionId, key)) {
  //       auto value = writeKey.get_value();
  //       std::atomic<uint64_t> &tid = table->search_metadata(key);
  //       table->update(key, value);
  //       TwoPLHelper::write_lock_release(tid, commit_tid);
  //     } else {
  //       txn.pendingResponses++;
  //       auto coordinatorID = partitioner.master_coordinator(tableId, partitionId, key);
  //       txn.network_size += MessageFactoryType::new_release_write_lock_message(
  //           *messages[coordinatorID], *table, writeKey.get_key(), commit_tid);
  //     }
  //   }

  //   sync_messages(txn);
  // }

  // void sync_messages(TransactionType &txn, bool wait_response = true) {
  //   txn.message_flusher();
  //   if (wait_response) {
  //     while (txn.pendingResponses > 0) {
  //       txn.remote_request_handler();
  //     }
  //   }
  // }

  // void async_txn_to_recorder(TransactionType &txn, std::vector<std::unique_ptr<Message>> &recordMessages) {
  //   /**
  //    * @brief 发给每个coordinator的recorder， 统计txn的record关联度情况
  //    * @add by truth 22-01-12
  //    * @modify by truth 22-02-24
  //    * @note std::vector<int32_t> record_key_in_this_txn
  //    *      |  4bit    |  28bit  |
  //    *      |  tableID |  keyID  |
  //   */
  //   const std::vector<u_int64_t> record_key_in_this_txn = txn.get_query();

  //   for (auto k = 0u; k < partitioner.total_coordinators(); k++) {
  //     // 给每一个coordinator都发送该信息
  //       txn.network_size +=
  //           MessageFactoryType::new_async_txn_of_record_message(
  //               *recordMessages[k], record_key_in_this_txn);
  //   }
  // }



      // txn.lock_request_handler =
    //     [this, &protocol, &txn](std::size_t table_id, std::size_t partition_id,
    //                  uint32_t key_offset, const void *key, void *value,
    //                  bool local_index_read, bool write_lock, bool &success,
    //                  bool &remote) -> uint64_t {
    //   if (local_index_read) {
    //     success = true;
    //     remote = false;
    //     return protocol.search(table_id, partition_id, key, value);
    //   }

    //   ITable *table = this->db.find_table(table_id, partition_id);

    //   if (txn.partitioner.has_master_partition(table_id, partition_id, key)) {

    //     remote = false;

    //     std::atomic<uint64_t> &tid = table->search_metadata(key);

    //     if (write_lock) {
    //       TwoPLHelper::write_lock(tid, success);
    //     } else {
    //       TwoPLHelper::read_lock(tid, success);
    //     }

    //     if (success) {
    //       return protocol.search(table_id, partition_id, key, value);
    //     } else {
    //       return 0;
    //     }

    //   } else {

    //     remote = true;

    //     auto coordinatorID =
    //         txn.partitioner.master_coordinator(table_id, partition_id, key);

    //     if (write_lock) {
    //       txn.network_size += MessageFactoryType::new_write_lock_message(
    //           *(this->messages[coordinatorID]), *table, key, key_offset);
    //     } else {
    //       txn.network_size += MessageFactoryType::new_read_lock_message(
    //           *(this->messages[coordinatorID]), *table, key, key_offset);
    //     }
    //     txn.distributed_transaction = true;
    //     return 0;
    //   }
    // };
